%%% 6_1
%~ Построить сеть Хопфилда, которая будет хранить образы из заданного набора.
%~ Эталонными образами являются двоичные изображения цифр 0, 1, 2, 3, 4, 6, 9
%~ размером 12х10. Проверить работу сети с зашумленными образами.
clear;
clc;

p1 = [-1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1;
      -1 -1 -1 1 1 1 1 -1 -1 -1; 
      -1 -1 -1 1 1 1 1 -1 -1 -1];

p2 = [1 1  1  1  1  1 -1 -1 -1 -1;
      1 1  1  1  1  1 -1 -1 -1 -1;
      1 1 -1 -1 -1 -1 -1 -1 -1 -1;
      1 1 -1 -1 -1 -1 -1 -1 -1 -1;
      1 1  1  1  1  1 -1 -1 -1 -1;
      1 1  1  1  1  1 -1 -1 -1 -1;
      1 1 -1 -1  1  1 -1 -1 -1 -1;
      1 1 -1 -1  1  1 -1 -1 -1 -1;
      1 1 -1 -1  1  1 -1 -1 -1 -1;
      1 1 -1 -1  1  1 -1 -1 -1 -1;
      1 1  1  1  1  1 -1 -1 -1 -1;
      1 1  1  1  1  1 -1 -1 -1 -1];

p3 = [-1  1  1 -1 -1 -1 -1 1 1 -1;
      -1  1  1 -1 -1 -1 -1 1 1 -1;
      -1  1  1 -1 -1 -1 -1 1 1 -1;
      -1  1  1 -1 -1 -1 -1 1 1 -1;
      -1  1  1 -1 -1 -1 -1 1 1 -1;
      -1  1  1  1  1  1  1 1 1 -1;
      -1  1  1  1  1  1  1 1 1 -1;
      -1 -1 -1 -1 -1 -1 -1 1 1 -1;
      -1 -1 -1 -1 -1 -1 -1 1 1 -1;
      -1 -1 -1 -1 -1 -1 -1 1 1 -1;
      -1 -1 -1 -1 -1 -1 -1 1 1 -1;
      -1 -1 -1 -1 -1 -1 -1 1 1 -1];   


%% 1.1
%~ Создать сеть с помощью функции newhop. Аттракторами построенной сети должны быть 3 образа,
%~ которые определяются вариантом задания. Каждый эталонный образ задается матрицей.
%~ Цветам точек соответствуют -1 и 1. Для синтеза сети необходимо
%~ объединить эталонные образы по формуле T = [p1(:), p2(:), p3(:)].
%~ Отобразить структуру сети c помощью функций display.
T = [p1(:),p2(:),p3(:)];
net = newhop(T);
display(net);
view(net);


%% 1.2
%~ Подать в сеть первый образ, рассчитать выход сети.
%~ Число итераций задать равным 100. Результат распознавания занести в отчет.
%~ Для этого с помощью функции reshape(p1, 12, 10) преобразовать выход сети
%~ и заменить в полученной матрице значения по правилу
%~ aij >= 0 -> xij = 2;
%~ aij < 0  -> xij = 1;
%~ Для отображения результата распознавания использовать вызов следующих функций:
%~ map = [1, 1, 1; 0, 0, 0];
%~ image(X); colormap(map)
%~ axis off
%~ axis image
X = sim(net, {1 100}, [], p1(:));
X = reshape(X{100},12,10);
X(X >= 0) = 2;
X(X < 0) = 1;



%% 1.3
%~ Произвести зашумление второго образа на 20%, полученный образ занести в отчет.
%~ Рассчитать выход сети. Число итераций задать равным 100.
%~ Результат распознавания занести в отчет.
r = rand(12,10);
input = p2;
for i=1:12
    for j=1:10
        if r(i,j) < 0.2
            input(i, j) = -input(i,j);  
        end
    end
end
X = input;
X(X >= 0) = 2;
X(X < 0) = 1;
map = [1,1,1;0,0,0];
figure;
image(X);
colormap(map)
axis off
axis image

X = sim(net, {1 100}, [], input(:));
X = reshape(X{100},12,10);
X(X >= 0) = 2;
X(X < 0) = 1;

map = [1,1,1;0,0,0];
figure;
image(X);
colormap(map)
axis off
axis image

%% 1.4
%~ Зашумление произвести следующим образом: для каждой точки изображения изменить цвет по правилу
%~ if rij < M then инвертировать цвет точки, где M — степень зашумления,
%~ r — реализация случайной величины, распределенной по равномерному закону (функция rand).


%% 1.5
%~ Произвести зашумление третьего образа на 30%, полученный образ занести в отчет.
%~ Рассчитать выход сети. Число итераций задать равным 600. Если необходимо, то произвести обучение несколько раз.
%~ Если результаты распознавания неудовлетворительные, то увеличить число итераций.
%~ Результат распознавания занести в отчет.

r = rand(12,10);
input = p3;
for i=1:12
    for j=1:10
        if r(i,j) < 0.3
            input(i, j) = -input(i,j);  
        end
    end
end
X = input;
X(X >= 0) = 2;
X(X < 0) = 1;
map = [1,1,1;0,0,0];
figure;
image(X);
colormap(map)
axis off
axis image

X = sim(net, {1 600}, [], input(:));
X = reshape(X{600},12,10);
X(X >= 0) = 2;
X(X < 0) = 1;

map = [1,1,1;0,0,0];
figure;
image(X);
colormap(map)
axis off
axis image




